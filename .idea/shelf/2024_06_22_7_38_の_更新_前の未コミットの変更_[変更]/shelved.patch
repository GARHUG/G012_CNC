Index: src/parser.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"2024.06.18\"\"\"\r\n\r\nfrom enum import Enum\r\nimport math\r\nimport re\r\nfrom typing import Generator\r\n\r\nimport state\r\n\r\n\r\nclass Parser:\r\n    def __init__(self, modal: state.Modal, programs: state.Programs,\r\n                 variables: state.Variables):\r\n        # 参照\r\n        self.modal = modal\r\n        self.programs = programs\r\n        self.variables = variables\r\n        # メモ\r\n        self.index = []\r\n        self.g29 = [0, 0, 0, 0, 0]\r\n\r\n    def mdi(self, block: str):\r\n        self.parse(block)\r\n\r\n    def cycle_start(self, program_num: int, row: int) -> Generator:\r\n        if not self.programs.is_exist(program_num):\r\n            raise NCParserError(\"プログラムが存在しません．\")\r\n        if self.get_while_range(program_num, row) != (-1, -1):\r\n            raise NCParserError(\"WHILE文中からは開始出来ません．\")\r\n        self.index.clear()\r\n        self.index.append({\"p\": program_num, \"r\": row})\r\n        for block in self.next():\r\n            self.parse(block)\r\n            yield\r\n\r\n    def parse(self):\r\n        \"\"\"indexを更新する\"\"\"\r\n        block = self.programs.read_block(self.p, self.r)\r\n        block = self.prepare(block)\r\n        self.check_mixed_gcode_and_macro(block)\r\n        while not block:  # 空行\r\n            self.nl()\r\n        # マクロ\r\n        if self.is_sub_block(block):\r\n            self.sub(block)\r\n        elif self.is_goto_block(block):\r\n            self.goto(block)\r\n        elif self.is_if_block(block):\r\n            self.if_(block)\r\n        elif self.is_while_block(block):\r\n            self.while_(block)\r\n        elif self.is_end_block(block):\r\n            self.end(block)\r\n        # Gコード\r\n        else:\r\n            ...\r\n\r\n    def parse_gcode(self, block):\r\n        sb = self.split_gcode(block)\r\n        for a, v in sb:\r\n            v = self.solve_value_or_none(v)\r\n            if a == \"G\":\r\n                gr = self.get_group(v)\r\n                if gr == 1:\r\n                    self.modal.gr1 = v\r\n\r\n\r\n\r\n\r\n    def sub(self, block: str):\r\n        sb = self.split_sub(block)\r\n        key = self.to_int(self.solve_value(sb[0][1]))\r\n        val = self.solve_value_or_none(sb[1][1])\r\n        self.variables.write(key, val)\r\n        self.nl()\r\n\r\n    def goto(self, block: str):\r\n        program = self.programs.read(self.p)\r\n        target_n = self.to_int(self.solve_value(self.split_goto(block)[0][1]))\r\n        # 下を検索\r\n        for i, block in enumerate(program[self.r + 1:]):\r\n            block = self.prepare(block)\r\n            pat = re.search(f\".*N({self.get_val_pat()})\", block)\r\n            if pat is None:\r\n                continue\r\n            n = self.to_int(self.solve_value(pat.group(1)))\r\n            if n == target_n:\r\n                row = self.r + i + 1\r\n                if self.can_jump(self.p, self.r, row):\r\n                    self.r = row\r\n                    return\r\n                else:\r\n                    raise NCParserError(\"WHILE文中には飛べません．\")\r\n        # 上を検索\r\n        for i, block in enumerate(program[:self.r]):\r\n            block = self.prepare(block)\r\n            pat = re.search(f\".*N({self.get_val_pat()})\", block)\r\n            if pat is None:\r\n                continue\r\n            n = self.to_int(self.solve_value(pat.group(1)))\r\n            if n == target_n:\r\n                if self.can_jump(self.p, self.r, i):\r\n                    self.r = i\r\n                    return\r\n                else:\r\n                    raise NCParserError(\"WHILE文中には飛べません．\")\r\n        # 見つからない\r\n        raise NCParserError(\"シーケンス番号が見つかりません．\")\r\n\r\n    def if_(self, block: str):\r\n        sb = self.split_if(block)\r\n        if self.solve_formula(sb[0][1]):\r\n            if sb[1][:4] == \"GOTO\":\r\n                self.goto(sb[1])\r\n            else:\r\n                self.sub(sb[1][4:])\r\n                self.nl()\r\n        else:\r\n            self.nl()\r\n\r\n    def while_(self, block: str):\r\n        sb = self.split_while(block)\r\n        do = self.to_int(self.solve_value(sb[1][1]))\r\n        if do not in {1, 2, 3}:\r\n            raise NCParserError(\"DO番号が不正です．\")\r\n        # 式がTrue\r\n        if self.solve_formula(sb[0][1]):\r\n            self.nl()\r\n        # 式がFalse\r\n        else:\r\n            for i, block in enumerate(self.programs.read(self.p)[self.r:]):\r\n                block = self.prepare(block)\r\n                if self.is_end_block(block) and do == self.to_int(self.solve_value(self.split_end(block)[0][1])):\r\n                    r = self.r + i\r\n                    if self.can_jump(self.p, self.r, r):\r\n                        self.r = r\r\n                    else:\r\n                        raise NCParserError(\"WHILE文中には飛べません．\")\r\n\r\n    def end(self, block: str):\r\n        program = self.programs.read(self.p)\r\n        target_do = self.to_int(self.solve_value(self.split_end(block)[0][1]))\r\n        # 上を下から検索\r\n        for i, block in enumerate(program[self.r::-1]):\r\n            block = self.prepare(block)\r\n            if self.is_do_block(block):\r\n                do = self.to_int(self.solve_value(self.split_do(block)[0][1]))\r\n                if target_do == do:\r\n                    if self.can_jump(self.p, self.r, self.r - i):\r\n                        self.r -= i\r\n                        return\r\n                    else:\r\n                        raise NCParserError(\"WHILE文中には飛べません．\")\r\n        # 見つからない\r\n        raise NCParserError(\"DO番号が見つかりません．\")\r\n\r\n    def nl(self):\r\n        self.r += 1\r\n\r\n    @classmethod\r\n    def prepare(cls, block: str) -> str:\r\n        block = cls.remove_comments(block)\r\n        block = cls.remove_not_allow_str(block)\r\n        return block\r\n\r\n    @staticmethod\r\n    def remove_comments(block: str) -> str:\r\n        is_in_comments = False\r\n        result = \"\"\r\n        for s in block:\r\n            if s == \"(\":\r\n                is_in_comments = True\r\n            elif s == \")\":\r\n                is_in_comments = False\r\n            elif is_in_comments:\r\n                pass\r\n            else:\r\n                result += s\r\n        return result\r\n\r\n    @staticmethod\r\n    def remove_not_allow_str(block: str) -> str:\r\n        \"\"\"事前にParse.remove_comments()使用の事\"\"\"\r\n        result = re.sub(\"[^A-Z0-9.#=+\\-*/[\\]]\", \"\", block)\r\n        if len(result) != len(block):\r\n            raise NCParserError(f\"無効な文字が含まれています．: {block}\")\r\n        return result\r\n\r\n    @staticmethod\r\n    def get_group(g: float) -> int:\r\n        if g in {4, 5, 5.1, 8, 9, 10, 11, 27, 28, 29, 30, 31, 37, 39,\r\n                 45, 46, 47, 48, 52, 53, 60, 65, 92, 107}:\r\n            return 0\r\n        elif g in {0, 1, 2, 3, 33, 75, 77, 78, 79}:\r\n            return 1\r\n        elif g in {17, 18, 19}:\r\n            return 2\r\n        elif g in {90, 91}:\r\n            return 3\r\n        elif g in {22, 23}:\r\n            return 4\r\n        elif g in {94, 95}:\r\n            return 5\r\n        elif g in {20, 21}:\r\n            return 6\r\n        elif g in {40, 41, 42}:\r\n            return 7\r\n        elif g in {43, 44, 49}:\r\n            return 8\r\n        elif g in {73, 74, 76, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89}:\r\n            return 9\r\n        elif g in {98, 99}:\r\n            return 10\r\n        elif g in {50, 51}:\r\n            return 11\r\n        elif g in {66, 67}:\r\n            return 12\r\n        elif g in {96, 97}:\r\n            return 13\r\n        elif g in {54, 54.1, 55, 56, 57, 58, 59}:\r\n            return 14\r\n        elif g in {61, 62, 63, 64}:\r\n            return 15\r\n        elif g in {68, 69}:\r\n            return 16\r\n        elif g in {15, 16}:\r\n            return 17\r\n        elif g in {151, 152}:\r\n            return 19\r\n        elif g in {160, 161}:\r\n            return 20\r\n        else:\r\n            raise NCParserError(f\"このGコードはサポートしていません．: {g}\")\r\n\r\n    def get_while_range(self, program: int, row: int) -> tuple:\r\n        \"\"\"\r\n        一番内側のWHILE文とEND文の行番号を返す．\r\n        start, endの初期値は-1\r\n        :return start, end\r\n        \"\"\"\r\n        program = self.programs.read(program)\r\n        for i, block1 in enumerate(program[row-1::-1]):\r\n            i += 1\r\n            block1 = self.prepare(block1)\r\n            if not self.is_while_block(block1):\r\n                continue\r\n            do = self.to_int(self.solve_value(self.split_while(block1)[1][1]))\r\n            for j, block2 in enumerate(program[row-i:]):\r\n                block2 = self.prepare(block2)\r\n                if not self.is_end_block(block2):\r\n                    continue\r\n                if do != self.to_int(self.solve_value(self.split_end(block2)[0][1])):\r\n                    continue\r\n                if i < j:\r\n                    return row - i, row - i + j\r\n                raise NCParserError(f\"END文が見つかりません．: {program[row-i]}\")\r\n        else:\r\n            return -1, -1\r\n\r\n    @staticmethod\r\n    def is_sub_block(block: str) -> bool:\r\n        \"\"\"事前にParse.prepare()使用の事\"\"\"\r\n        return \"=\" in block and \"IF\" not in block\r\n\r\n    @staticmethod\r\n    def is_goto_block(block: str) -> bool:\r\n        return \"GOTO\" in block and \"IF\" not in block\r\n\r\n    @staticmethod\r\n    def is_if_block(block: str) -> bool:\r\n        return (\"GOTO\" in block or \"THEN\" in block) and \"IF\" in block\r\n\r\n    @staticmethod\r\n    def is_while_block(block: str) -> bool:\r\n        return \"WHILE\" in block and \"DO\" in block\r\n\r\n    @staticmethod\r\n    def is_do_block(block: str) -> bool:\r\n        return \"DO\" in block\r\n\r\n    @staticmethod\r\n    def is_end_block(block: str):\r\n        return \"END\" in block\r\n\r\n    @staticmethod\r\n    def is_bool_formula(formula: str) -> bool:\r\n        \"\"\"事前にParse.prepare()使用の事\"\"\"\r\n        keywords = {\"EQ\", \"NE\", \"GT\", \"LT\", \"GE\", \"LE\"}\r\n        for keyword in keywords:\r\n            if keyword in formula:\r\n                return True\r\n        else:\r\n            return False\r\n\r\n    @staticmethod\r\n    def is_logic_formula(formula: str) -> bool:\r\n        \"\"\"事前にParse.prepare()使用の事\"\"\"\r\n        keywords = {\"AND\", \"OR\"}\r\n        for keyword in keywords:\r\n            if keyword in formula:\r\n                return True\r\n        else:\r\n            return False\r\n\r\n    @staticmethod\r\n    def is_num(value: str) -> bool:\r\n        try:\r\n            float(value)\r\n        except ValueError:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n    def is_in_while(self, program: int, row: int) -> bool:\r\n        \"\"\"WHILE文,END文はFalse.GOTO文で飛べるか？で判断．\"\"\"\r\n        depth = 0\r\n        for i, block in enumerate(self.programs.read(program)):\r\n            block = self.prepare(block)\r\n            if self.is_end_block(block):\r\n                depth -= 1\r\n            if row == i:\r\n                return depth == 0\r\n            if self.is_while_block(block):\r\n                depth += 1\r\n\r\n    @classmethod\r\n    def check_mixed_gcode_and_macro(cls, block: str):\r\n        is_macro = False\r\n        if cls.is_sub_block(block):\r\n            is_macro = True\r\n            block = re.sub(cls.get_sub_pat(), \"\", block)\r\n        if cls.is_goto_block(block):\r\n            is_macro = True\r\n            block = re.sub(cls.get_goto_pat(), \"\", block)\r\n        if cls.is_if_block(block):\r\n            is_macro = True\r\n            block = re.sub(cls.get_if_pat(), \"\", block)\r\n        if cls.is_while_block(block):\r\n            is_macro = True\r\n            block = re.sub(cls.get_while_pat(), \"\", block)\r\n        if cls.is_do_block(block):\r\n            is_macro = True\r\n            block = re.sub(cls.get_do_pat(), \"\", block)\r\n        if cls.is_end_block(block):\r\n            is_macro = True\r\n            block = re.sub(cls.get_end_pat(), \"\", block)\r\n        if not is_macro:\r\n            return\r\n        block = re.sub(f\"N{cls.get_val_pat()}\", \"\", block)\r\n        block = re.sub(f\"O{cls.get_val_pat()}\", \"\", block)\r\n        if block:\r\n            raise NCParserError(\"Gコードとマクロが混在しています．\")\r\n\r\n    def can_jump(self, program: int, row1: int, row2):\r\n        \"\"\"プログラム番号{program}の行{row1}から行{row2}にGOTO,ENDで飛べるか？\"\"\"\r\n        s1, e1 = self.get_while_range(program, row1)\r\n        s2, e2 = self.get_while_range(program, row2)\r\n        return s1 >= s2 and e1 <= e2\r\n\r\n    @classmethod\r\n    def split_sub(cls, block: str) -> list:\r\n        \"\"\"return: [(\"#\", 値), (\"=\", 値)]\"\"\"\r\n        enc = re.findall(cls.get_sub_pat(), block)\r\n        if len(enc) != 1:\r\n            raise NCParserError(f\"無効な代入文です．: {block}\")\r\n        return cls.split_len_check(block, [(\"#\", enc[0][0]), (\"=\", enc[0][3])])\r\n\r\n    @classmethod\r\n    def split_goto(cls, block: str) -> list:\r\n        \"\"\"return: [(\"GOTO\", 値)]\"\"\"\r\n        enc = re.findall(cls.get_goto_pat(), block)\r\n        if len(enc) != 1:\r\n            raise NCParserError(f\"無効なGOTO文です．: {block}\")\r\n        return cls.split_len_check(block, [(\"GOTO\", enc[0][0])])\r\n\r\n    @classmethod\r\n    def split_if(cls, block: str) -> list:\r\n        \"\"\"return: [(\"IF\", 式), (マクロ命令)]\"\"\"\r\n        enc = re.findall(cls.get_if_pat(), block)\r\n        if len(enc) != 1:\r\n            raise NCParserError(f\"無効なIF文です．: {block}\")\r\n        fml = enc[0][0]\r\n        if fml[0] != \"[\" or fml[-1] != \"]\":\r\n            raise NCParserError(f\"式がカッコに囲まれていません．: {block}\")\r\n        return cls.split_len_check(block, [(\"IF\", fml), (enc[0][3])])\r\n\r\n    @classmethod\r\n    def split_while(cls, block: str) -> list:\r\n        \"\"\"return: [(\"WHILE\", 式), (\"DO\", 値)]\"\"\"\r\n        enc = re.findall(cls.get_while_pat(), block)\r\n        if len(enc) != 1:\r\n            raise NCParserError(f\"無効なWHILE文です．: {block}\")\r\n        fml = enc[0][0]\r\n        if fml[0] != \"[\" or fml[-1] != \"]\":\r\n            raise NCParserError(f\"式がカッコに囲まれていません．: {block}\")\r\n        return cls.split_len_check(block, [(\"WHILE\", fml), (\"DO\", enc[0][3])])\r\n\r\n    @classmethod\r\n    def split_do(cls, block: str) -> list:\r\n        \"\"\"return: [(\"DO\", 値)]\"\"\"\r\n        enc = re.findall(cls.get_do_pat(), block)\r\n        if len(enc) != 1:\r\n            raise NCParserError(f\"無効なDO文です．: {block}\")\r\n        return cls.split_len_check(block, [(\"DO\", enc[0][0])])\r\n\r\n    @classmethod\r\n    def split_end(cls, block: str) -> list:\r\n        \"\"\"return: [(\"END\", 値)]\"\"\"\r\n        enc = re.findall(cls.get_end_pat(), block)\r\n        if len(enc) != 1:\r\n            raise NCParserError(f\"無効なEND文です．: {block}\")\r\n        return cls.split_len_check(block, [(\"END\", enc[0][0])])\r\n\r\n    @classmethod\r\n    def split_gcode(cls, block: str) -> list:\r\n        \"\"\"[(アドレス, 値)]\"\"\"\r\n        val_pat = cls.get_val_pat()\r\n        enc = re.finditer(f\"([A-Z])({val_pat})\", block)\r\n        return cls.split_len_check(block, [(ad, val) for ad, val, _ in enc])\r\n\r\n    @staticmethod\r\n    def split_len_check(block: str, block_split: list) -> list:\r\n        join = []\r\n        for i in block_split:\r\n            for j in i:\r\n                join.append(j)\r\n        join = \"\".join(join)\r\n        if block != join:\r\n            raise NCParserError(f\"アドレスが不です．: {block}\")\r\n        else:\r\n            return block_split\r\n\r\n    @staticmethod\r\n    def get_val_pat() -> str:\r\n        return \"([-+*/[\\].#0-9]|SQRT|ABS|SIN|COS|TAN|ATAN|ROUND|FIX|FUP|BIN|BCD)+\"\r\n\r\n    @classmethod\r\n    def get_formula_pat(cls) -> str:\r\n        return f\"({cls.get_val_pat}|EQ|NE|GT|LT|GE|LE|AND|OR)+\"\r\n\r\n    @classmethod\r\n    def get_sub_pat(cls) -> str:\r\n        vp = cls.get_val_pat()\r\n        return f\"#({vp})=({vp})\"\r\n\r\n    @classmethod\r\n    def get_goto_pat(cls) -> str:\r\n        vp = cls.get_val_pat()\r\n        return f\"GOTO({vp})\"\r\n\r\n    @classmethod\r\n    def get_if_pat(cls) -> str:\r\n        vp = cls.get_val_pat()\r\n        fp = cls.get_formula_pat()\r\n        return f\"IF({fp})((THEN#{vp}={vp})|GOTO{vp})\"\r\n\r\n    @classmethod\r\n    def get_while_pat(cls) -> str:\r\n        vp = cls.get_val_pat()\r\n        fp = cls.get_formula_pat()\r\n        return f\"WHILE({fp})DO({vp})\"\r\n\r\n\r\n    @classmethod\r\n    def get_do_pat(cls) -> str:\r\n        vp = cls.get_val_pat()\r\n        return f\"DO({vp})\"\r\n\r\n    @classmethod\r\n    def get_end_pat(cls) -> str:\r\n        vp = cls.get_val_pat()\r\n        return f\"END({vp})\"\r\n\r\n    def solve_value(self, value: str) -> float:\r\n        \"\"\"エンコードされた値を計算\"\"\"\r\n        # 四則演算で分割\r\n        result = self.split_asmd(value)\r\n        # 分割した要素の偶数番目を式から値に変換\r\n        # 奇数番目は[+-*/]、偶数番目は値\r\n        for i, val in enumerate(result[::2]):\r\n            i = i * 2\r\n            if self.is_num(val):\r\n                pass\r\n            elif val[0] == \"[\" and val[-1] == \"]\":\r\n                result[i] = self.solve_value(val[1:-1])\r\n            elif val[0] == \"#\":\r\n                v = self.solve_value(val[1:])\r\n                try:\r\n                    v = self.to_int(v)\r\n                except NCParserError:\r\n                    raise NCParserError(\r\n                        f\"マクロキーが整数ではありません．: {value}\")\r\n                if v == 0:\r\n                    result[i] = 0\r\n                else:\r\n                    result[i] = self.variables.read(self.to_int(v))\r\n            elif val[:4] == \"SQRT\":\r\n                v = self.solve_value(val[5:-1])\r\n                result[i] = math.sqrt(v)\r\n            elif val[:3] == \"ABS\":\r\n                v = self.solve_value(val[4:-1])\r\n                result[i] = abs(v)\r\n            elif val[:3] == \"SIN\":\r\n                v = self.solve_value(val[4:-1])\r\n                result[i] = math.sin(v)\r\n            elif val[:3] == \"COS\":\r\n                v = self.solve_value(val[4:-1])\r\n                result[i] = math.cos(v)\r\n            elif val[:3] == \"TAN\":\r\n                v = self.solve_value(val[4:-1])\r\n                result[i] = math.tan(v)\r\n            elif val[:4] == \"ATAN\":\r\n                v = self.solve_value(val[5:-1])\r\n                result[i] = math.atan(v)\r\n            elif val[:5] == \"ROUND\":\r\n                v = self.solve_value(val[6:-1])\r\n                result[i] = round(v)\r\n            elif val[:3] == \"FIX\":\r\n                v = self.solve_value(val[4:-1])\r\n                result[i] = math.floor(v)\r\n            elif val[:3] == \"FUP\":\r\n                v = self.solve_value(val[4:-1])\r\n                result[i] = math.ceil(v)\r\n            elif val[:3] == \"BIN\":\r\n                v = self.solve_value(val[4:-1])\r\n                result[i] = self.bin(str(v))\r\n            elif val[:3] == \"BCD\":\r\n                v = self.solve_value(val[4:-1])\r\n                result[i] = self.bcd(str(v))\r\n            else:\r\n                assert False\r\n        # 四則演算\r\n        return eval(\"\".join(map(str, result)))\r\n\r\n    def solve_value_or_none(self, value: str) -> float or None:\r\n        if value[0] == \"#\" and self.solve_value(value[1:]) == 0:\r\n            return None\r\n        else:\r\n            return self.solve_value(value)\r\n\r\n    @staticmethod\r\n    def split_asmd(value: str) -> list:\r\n        result = []\r\n        bkt_cnt = 0\r\n        tmp = \"\"\r\n        for s in value:\r\n            if s == \"[\":\r\n                bkt_cnt += 1\r\n            elif s == \"]\":\r\n                bkt_cnt -= 1\r\n            if bkt_cnt == 0 and s in {\"+\", \"-\", \"*\", \"/\"}:\r\n                result.append(tmp)\r\n                result.append(s)\r\n                tmp = \"\"\r\n            else:\r\n                tmp += s\r\n        if bkt_cnt != 0:\r\n            raise NCParserError(f\"カッコが一致しません．: {value}\")\r\n        result.append(tmp)\r\n        if not result[0]:\r\n            result[0] = \"0\"\r\n        return result\r\n\r\n    @staticmethod\r\n    def bcd(value: str) -> float:\r\n        if re.search(\"[^01]\", value):\r\n            raise NCParserError(f\"BCD計算出来ません．: {value}\")\r\n        q, mod = divmod(len(value), 4)\r\n        result = 0\r\n        # 足りない0を補充\r\n        if mod != 0:\r\n            value = \"0\" * (4 - mod) + value\r\n            q += 1\r\n        # 計算\r\n        for i, j in enumerate(range(q - 1, -1, -1)):\r\n            i = i * 4\r\n            result += int(value[i:i + 4], 2) * 10 ** j\r\n        return result\r\n\r\n    @staticmethod\r\n    def bin(value: str) -> float:\r\n        try:\r\n            Parser.to_int(value)\r\n        except NCParserError:\r\n            raise NCParserError(f\"BIN計算出来ません．: {value}\")\r\n        result = \"\"\r\n        for s in value:\r\n            b = bin(int(s))[2:].zfill(4)\r\n            result += b\r\n        return float(result)\r\n\r\n    def solve_formula(self, formula: str) -> bool:\r\n        \"\"\"エンコードされた式を評価\"\"\"\r\n        formula = self.split_logic(formula)\r\n        for i, f in enumerate(formula[::2]):\r\n            i = i * 2\r\n            if self.is_logic_formula(f):\r\n                formula[i] = self.solve_formula(f)\r\n            elif self.is_bool_formula(f):\r\n                formula[i] = self.solve_bool(f)\r\n            else:\r\n                raise NCParserError(f\"式が不正です．: {formula}\")\r\n        return self.solve_logic(formula)\r\n\r\n    @staticmethod\r\n    def solve_logic(formula: list) -> bool:\r\n        # ANDを処理\r\n        ix = 1\r\n        while ix < len(formula):\r\n            if formula[ix] == \"AND\":\r\n                if formula[ix - 1] and formula[ix + 1]:\r\n                    formula[ix - 1:ix + 2] = True\r\n                else:\r\n                    formula[ix - 1:ix + 2] = False\r\n                ix -= 1\r\n            else:\r\n                ix += 2\r\n        # ORを処理\r\n        ix = 1\r\n        while ix < len(formula):\r\n            if formula[ix] == \"OR\":\r\n                if formula[ix - 1] or formula[ix + 1]:\r\n                    formula[ix - 1:ix + 2] = True\r\n                else:\r\n                    formula[ix - 1:ix + 2] = False\r\n                ix -= 1\r\n            else:\r\n                ix += 2\r\n        assert len(formula) == 1\r\n        return formula[0]\r\n\r\n    @staticmethod\r\n    def split_logic(formula: str) -> list:\r\n        result = []\r\n        bkt_cnt = 0\r\n        tmp = \"\"\r\n        ix = 0\r\n        while ix < len(formula):\r\n            if formula[ix] == \"[\":\r\n                bkt_cnt += 1\r\n            elif formula[ix] == \"]\":\r\n                bkt_cnt -= 1\r\n            if bkt_cnt == 0:\r\n                result.append(tmp)\r\n                tmp = \"\"\r\n                if formula[ix] == \"A\" and formula[ix] == \"N\" and formula[\r\n                    ix] == \"D\":\r\n                    result.append(\"AND\")\r\n                    ix += 3\r\n                elif formula[ix] == \"O\" and formula[ix] == \"R\":\r\n                    result.append(\"OR\")\r\n                    ix += 2\r\n            else:\r\n                tmp += formula[ix]\r\n                ix += 1\r\n        result.append(tmp)\r\n        if bkt_cnt != 0:\r\n            raise NCParserError(f\"カッコが一致しません．: {formula}\")\r\n        if (result[0] == \"AND\" or result[0] == \"OR\"\r\n                or result[-1] == \"AND\" or result[-1] == \"OR\"):\r\n            raise NCParserError(f\"式が不正です．: {formula}\")\r\n        return result\r\n\r\n    def solve_bool(self, formula: str) -> bool:\r\n        formula = re.search(\r\n            f\"({self.get_val_pat()})(EQ|NE|GT|LT|GE|LE)({self.get_val_pat()})\",\r\n            formula)\r\n        if formula is None:\r\n            raise NCParserError(f\"式を評価出来ません．: {formula}\")\r\n        val1 = self.solve_value_or_none(formula.group(1))\r\n        com = formula.group(2)\r\n        val2 = self.solve_value_or_none(formula.group(3))\r\n        if com == \"EQ\":\r\n            return val1 == val2\r\n        if com == \"NE\":\r\n            return val1 != val2\r\n        if val1 is None:\r\n            val1 = 0\r\n        if val2 is None:\r\n            val2 = 0\r\n        if com == \"GT\":\r\n            return val1 < val2\r\n        if com == \"LT\":\r\n            return val1 > val2\r\n        if com == \"GE\":\r\n            return val1 <= val2\r\n        if com == \"LE\":\r\n            return val1 >= val2\r\n\r\n    @staticmethod\r\n    def to_coord(num: str) -> float:\r\n        if \".\" in num:\r\n            return float(num)\r\n        else:\r\n            return float(num) / 1000\r\n\r\n    @staticmethod\r\n    def to_int(num: str or float) -> int:\r\n        if num is None:\r\n            raise NCParserError(\"数値が#0です．\")\r\n        i = int(num)\r\n        if i == float(num):\r\n            return i\r\n        else:\r\n            raise NCParserError(f\"整数化出来ません．: {num}\")\r\n\r\n    @property\r\n    def p(self) -> int:\r\n        return self.index[-1][\"program_number\"]\r\n\r\n    @p.setter\r\n    def p(self, val: int):\r\n        assert isinstance(val, int)\r\n        self.index[-1][\"program_number\"] = val\r\n\r\n    @property\r\n    def r(self):\r\n        return self.index[-1][\"row\"]\r\n\r\n    @r.setter\r\n    def r(self, val: int):\r\n        assert isinstance(val, int)\r\n        self.index[-1][\"row\"] = val\r\n\r\n\r\nclass Reader:\r\n    def __init__(self, parser: Parser, state: State):\r\n        self.parser = parser\r\n        self.state = state\r\n        self.index = []\r\n\r\n    def cycle_start(self, program_num: int, row: int) -> Generator:\r\n        self.index = []\r\n        self.index.append({\"program_num\": program_num, \"row\": row})\r\n        for block in self.next():\r\n            yield block\r\n\r\n    def next(self) -> Generator:\r\n        while True:\r\n            assert 1 <= len(self.index)\r\n            try:\r\n                block = self.state.programs.read_block(\r\n                    self.index[-1][\"program_num\"],\r\n                    self.index[-1][\"row\"])\r\n            except IndexError:\r\n                raise NCParserError(\"ファイルの終端です．\")\r\n            block = Parser.prepare(block)\r\n\r\n\r\nclass NCParserError(Exception):\r\n    def __init__(self, *args):\r\n        self.args = args\r\n\r\n    def __str__(self):\r\n        return self.args\r\n\r\n\r\nclass GcodeList:\r\n    GROUP0 = {4, 4.1, 5, 5.1, 5.4, 7.1, 8, 9, 10, 10.6, 11, 24, 27, 28, 28.2,\r\n              29, 30, 30.2, 31, 32, 39, 52, 53, 53.2, 60, 63, 65, 72.1, 72.2,\r\n              75, 76, 77, 91.1, 92, 92.1, 107}\r\n    GROUP1 = {0, 1, 2, 3}\r\n    GROUP2 = {17, 18, 19}\r\n    GROUP3 = {90, 91}\r\n    GROUP4 = {22, 23}\r\n    GROUP5 = {}\r\n    GROUP6 = {20, 21, 70, 71}\r\n    GROUP7 = {40, 41, 42}\r\n    GROUP8 = {}\r\n    GROUP9 = {}\r\n    GROUP10 = {}\r\n    GROUP11 = {50, 51}\r\n    GROUP12 = {66, 66.1, 67}\r\n    GROUP13 = {}\r\n    GROUP14 = {54, 54.1, 55, 56, 57, 58, 59}\r\n    GROUP15 = {61, 62, 64}\r\n    GROUP16 = {68, 69, 84, 85}\r\n    GROUP17 = {15, 16}\r\n    GROUP18 = {40.1, 41.1, 42.1, 150, 151, 152}\r\n    GROUP19 = {}\r\n    GROUP20 = {}\r\n    GROUP38 = {13, 14}\r\n    GROUP42 = {13.2, 14.2}\r\n\r\n\r\nclass Address(Enum):\r\n    A = \"A\"\r\n    B = \"B\"\r\n    C = \"C\"\r\n    D = \"D\"\r\n    E = \"E\"\r\n    F = \"F\"\r\n    G = \"G\"\r\n    H = \"H\"\r\n    I = \"I\"\r\n    J = \"J\"\r\n    K = \"K\"\r\n    L = \"L\"\r\n    M = \"M\"\r\n    N = \"N\"\r\n    O = \"O\"\r\n    P = \"P\"\r\n    Q = \"Q\"\r\n    R = \"R\"\r\n    S = \"S\"\r\n    T = \"T\"\r\n    U = \"U\"\r\n    V = \"V\"\r\n    W = \"W\"\r\n    X = \"X\"\r\n    Y = \"Y\"\r\n    Z = \"Z\"\r\n    IF = \"IF\"\r\n    GOTO = \"GOTO\"\r\n    THEN = \"THEN\"\r\n    WHILE = \"WHILE\"\r\n    DO = \"DO\"\r\n    END = \"END\"\r\n    SUB = \"=\"\r\n\r\n\r\n\r\n\r\n\"\"\"\r\nclass MissingAddressNCError(Exception):\r\n    def __init__(self, arg):\r\n        self.arg = arg\r\n\r\n    def __str__(self):\r\n        return f\"アドレス{self.arg}が見つかりません．\"\r\n\r\n\r\nclass MissingSequenceNCReaderError(Exception):\r\n    def __init__(self, arg: int):\r\n        self.arg = arg\r\n\r\n    def __str__(self):\r\n        return f\"シーケンス番号{self.arg}が見つかりません．\"\r\n\r\n\r\nclass EndOfProgramNCReaderError(Exception):\r\n    def __str__(self):\r\n        return \"プログラム終端です．\"\r\n\r\n\r\nclass InvalidAddressNCError(Exception):\r\n    def __init__(self, arg):\r\n        self.arg = arg\r\n\r\n    def __str__(self):\r\n        return f\"アドレス{self.arg}は不正です．\"\r\n\"\"\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parser.py b/src/parser.py
--- a/src/parser.py	(revision ed2d7a74c4bbd47287ec50ed39162a6c73b708eb)
+++ b/src/parser.py	(date 1719009497665)
@@ -55,7 +55,9 @@
         else:
             ...
 
-    def parse_gcode(self, block):
+    def parse_modal(self, block):
+        ggr0 = []
+        ggr1 =
         sb = self.split_gcode(block)
         for a, v in sb:
             v = self.solve_value_or_none(v)
@@ -67,6 +69,8 @@
 
 
 
+
+
     def sub(self, block: str):
         sb = self.split_sub(block)
         key = self.to_int(self.solve_value(sb[0][1]))
@@ -363,7 +367,9 @@
         enc = re.findall(cls.get_sub_pat(), block)
         if len(enc) != 1:
             raise NCParserError(f"無効な代入文です．: {block}")
-        return cls.split_len_check(block, [("#", enc[0][0]), ("=", enc[0][3])])
+        sb = [("#", enc[0][0]), ("=", enc[0][3])]
+        cls.check_split_len(block, sb)
+        return sb
 
     @classmethod
     def split_goto(cls, block: str) -> list:
@@ -371,7 +377,9 @@
         enc = re.findall(cls.get_goto_pat(), block)
         if len(enc) != 1:
             raise NCParserError(f"無効なGOTO文です．: {block}")
-        return cls.split_len_check(block, [("GOTO", enc[0][0])])
+        sb = [("GOTO", enc[0][0])]
+        cls.check_split_len(block, sb)
+        return sb
 
     @classmethod
     def split_if(cls, block: str) -> list:
@@ -382,7 +390,9 @@
         fml = enc[0][0]
         if fml[0] != "[" or fml[-1] != "]":
             raise NCParserError(f"式がカッコに囲まれていません．: {block}")
-        return cls.split_len_check(block, [("IF", fml), (enc[0][3])])
+        sb = [("IF", fml), (enc[0][3])]
+        cls.check_split_len(block, sb)
+        return sb
 
     @classmethod
     def split_while(cls, block: str) -> list:
@@ -393,7 +403,9 @@
         fml = enc[0][0]
         if fml[0] != "[" or fml[-1] != "]":
             raise NCParserError(f"式がカッコに囲まれていません．: {block}")
-        return cls.split_len_check(block, [("WHILE", fml), ("DO", enc[0][3])])
+        sb = [("WHILE", fml), ("DO", enc[0][3])]
+        cls.check_split_len(block, sb)
+        return sb
 
     @classmethod
     def split_do(cls, block: str) -> list:
@@ -401,7 +413,9 @@
         enc = re.findall(cls.get_do_pat(), block)
         if len(enc) != 1:
             raise NCParserError(f"無効なDO文です．: {block}")
-        return cls.split_len_check(block, [("DO", enc[0][0])])
+        sb = [("DO", enc[0][0])]
+        cls.check_split_len(block, sb)
+        return sb
 
     @classmethod
     def split_end(cls, block: str) -> list:
@@ -409,17 +423,21 @@
         enc = re.findall(cls.get_end_pat(), block)
         if len(enc) != 1:
             raise NCParserError(f"無効なEND文です．: {block}")
-        return cls.split_len_check(block, [("END", enc[0][0])])
+        sb = [("END", enc[0][0])]
+        cls.check_split_len(block, sb)
+        return sb
 
     @classmethod
     def split_gcode(cls, block: str) -> list:
         """[(アドレス, 値)]"""
         val_pat = cls.get_val_pat()
         enc = re.finditer(f"([A-Z])({val_pat})", block)
-        return cls.split_len_check(block, [(ad, val) for ad, val, _ in enc])
+        sb = [(ad, val) for ad, val, _ in enc]
+        cls.check_split_len(block, sb)
+        return sb
 
     @staticmethod
-    def split_len_check(block: str, block_split: list) -> list:
+    def check_split_len(block: str, block_split: list):
         join = []
         for i in block_split:
             for j in i:
@@ -427,8 +445,21 @@
         join = "".join(join)
         if block != join:
             raise NCParserError(f"アドレスが不です．: {block}")
-        else:
-            return block_split
+
+    @classmethod
+    def grouping_split_g(cls, sb: list) -> list:
+        result = []
+        for a, v in sb:
+            if a == "G":
+                result.append(str((cls.get_group(v))), v)
+            else:
+                result.append((a, v))
+        return result
+
+    @classmethod
+    def sort_split_g(cls, sb: list) -> list:
+        result = []
+
 
     @staticmethod
     def get_val_pat() -> str:
